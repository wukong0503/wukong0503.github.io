---
title: 【整理】计算机网络
tags: 计算机网络
key: 2019123101
---

- [OSI七层模型和TCP/IP四层模型](#osi%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%92%8Ctcpip%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B)
  - [应用层](#%E5%BA%94%E7%94%A8%E5%B1%82)
  - [传输层](#%E4%BC%A0%E8%BE%93%E5%B1%82)
  - [网络层](#%E7%BD%91%E7%BB%9C%E5%B1%82)
  - [数据链路层](#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82)
  - [物理层](#%E7%89%A9%E7%90%86%E5%B1%82)
- [三次握手与四次挥手过程](#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B)
  - [三次握手](#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B)
  - [为什么需要三次握手，两次不行吗？](#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%A4%E6%AC%A1%E4%B8%8D%E8%A1%8C%E5%90%97)
  - [四次挥手](#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B)
  - [为什么建立连接是三次握手，而关闭连接却是四次挥手呢？](#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%80%8C%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5%E5%8D%B4%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%91%A2)
  - [客户端不断进行请求链接会怎样？DDos(Distributed Denial of Service)攻击？](#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8D%E6%96%AD%E8%BF%9B%E8%A1%8C%E8%AF%B7%E6%B1%82%E9%93%BE%E6%8E%A5%E4%BC%9A%E6%80%8E%E6%A0%B7ddosdistributed-denial-of-service%E6%94%BB%E5%87%BB)
- [TCP与UDP](#tcp%E4%B8%8Eudp)
  - [TCP与UDP的区别](#tcp%E4%B8%8Eudp%E7%9A%84%E5%8C%BA%E5%88%AB)
  - [TCP报文格式](#tcp%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F)
  - [TCP协议如何来保证传输的可靠性](#tcp%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E6%9D%A5%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7)
  - [滑动窗口和流量控制](#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6)
  - [拥塞控制](#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6)
- [HTTP和HTTPS](#http%E5%92%8Chttps)
  - [HTTP和HTTPS的区别](#http%E5%92%8Chttps%E7%9A%84%E5%8C%BA%E5%88%AB)
  - [HTTP长连接、短连接](#http%E9%95%BF%E8%BF%9E%E6%8E%A5%E7%9F%AD%E8%BF%9E%E6%8E%A5)
  - [HTTP1.0和HTTP1.1的主要区别是什么?](#http10%E5%92%8Chttp11%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88)
  - [HTTP2.0](#http20)
  - [Cookie和Session](#cookie%E5%92%8Csession)
- [GET与POST的区别](#get%E4%B8%8Epost%E7%9A%84%E5%8C%BA%E5%88%AB)
- [对称加密与非对称加密](#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E4%B8%8E%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86)
- [从输入网址到获得页面的过程☆☆☆☆☆](#%E4%BB%8E%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E8%8E%B7%E5%BE%97%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%BF%87%E7%A8%8B%E2%98%86%E2%98%86%E2%98%86%E2%98%86%E2%98%86)
- [参考](#%E5%8F%82%E8%80%83)



#### OSI七层模型和TCP/IP四层模型

##### 应用层

##### 传输层

##### 网络层

##### 数据链路层

##### 物理层


#### 三次握手与四次挥手过程

##### 三次握手

三次握手的目的是连接服务器指定端口，建立TCP连接，同步连接双方的序列号和确认号，并交换TCP窗口大小信息。
在socket编程中，客户端执行connect()时, 将触发三次握手。  

 - 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 `SYN_SEND` 状态。  

首部的同步位`SYN=1`，初始序号`seq=x`，**`SYN=1`的报文段不能携带数据**，但要消耗掉一个序号。


 - 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。  

在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。


 - 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。  

确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），**ACK报文段可以携带数据，不携带数据则不消耗序号**。


##### 为什么需要三次握手，两次不行吗？
三次握手的目的是建立可靠的通信信道，说道通讯，简单来说就是数据的发送和接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。

 + 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
 + 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。
 + 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

因此，需要三次握手才能确认双方的接收与发送能力是否正常。  
试想如果是用两次握手，则会出现下面这种情况：  

 > 如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。


##### 四次挥手
 - 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。  
 - 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。此时TCP链接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。    
 - 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。 
 - 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。


##### 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？
这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送。


[https://zhuanlan.zhihu.com/p/53374516](https://zhuanlan.zhihu.com/p/53374516)  
[https://juejin.im/post/5d9c284b518825095879e7a5](https://juejin.im/post/5d9c284b518825095879e7a5)


##### 客户端不断进行请求链接会怎样？DDos(Distributed Denial of Service)攻击？
服务器端会为每个请求创建一个链接，并向其发送确认报文，然后等待客户端进行确认。  

1)、DDos 攻击  
客户端向服务端发送请求链接数据包  
服务端向客户端发送确认数据包  
客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认  

2)、DDos 预防 ( 没有彻底根治的办法，除非不使用TCP )  
限制同时打开SYN半链接的数目  
缩短SYN半链接的Time out 时间  
关闭不必要的服务  


#### TCP与UDP

##### TCP与UDP的区别
##### TCP报文格式

![TCP报文格式](https://s1.51cto.com/images/20180821/1534845641472393.jpeg)

TCP报文由首部和数据两部分组成。首部一般由20-60字节（Byte）构成，长度可变。其中前20B格式固定，后40B为可选。

上图中有几个字段需要重点介绍下：   
 + **源端口与目标端口**: 分别写入源端口号和目标端口号
 + **序列号**: 也就是我们tcp三次握手中的`seq`, 表示的是我们tcp数据段发送的第一个字节的序号,范围[0, 2^32 - 1], 例如,我们的seq = 201,携带的数据有100,那么最后一个字节的序号就为300, 那么下一个报文段就应该从301开始.  
 + **确认序列号**: 也就是`ack`(假设为y), 它的值是`seq+1`,表示的意义是y之前的数据我都收到了,下一个我期望收到的数据是y.也就是我回过去的seq = y.  
 + **标志位**：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：  
   + （A）URG：紧急指针（urgent pointer）有效。  
   + （B）ACK：确认序号有效。  
   + （C）PSH：接收方应该尽快将这个报文交给应用层。  
   + （D）RST：重置连接。  
   + （E）SYN：发起一个新连接。  
   + （F）FIN：释放一个连接。  

需要注意的是：  
    （A）不要将确认序号Ack与标志位中的ACK搞混了。  
    （B）确认方Ack=发起方Seq+1，两端配对。


##### TCP协议如何来保证传输的可靠性

##### 滑动窗口和流量控制

##### 拥塞控制


#### HTTP和HTTPS

##### HTTP和HTTPS的区别

1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。  
2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。  
3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。  
4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 

[http://www.mahaixiang.cn/internet/1233.html](http://www.mahaixiang.cn/internet/1233.html)

##### HTTP长连接、短连接，优点和缺点，使用场景

##### HTTP1.0和HTTP1.1的主要区别是什么?

##### HTTP2.0

##### Cookie和Session

#### GET与POST的区别

#### 对称加密与非对称加密
对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；  
而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。

由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；**但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。**


#### 从输入网址到获得页面的过程☆☆☆☆☆

#### Socket是什么

Socket是应用层与TCP/IP协议簇通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实是一个门面模式，它把复杂的TCP/IP协议隐藏在Socket接口后面，
对用户来说，一组简单的接口就是全部，让Socket去组织数据，已符合指定的协议。

#### 参考
[JavaGuide/network](https://github.com/Snailclimb/JavaGuide/blob/master/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md)
[计算机网络基础知识总结](https://www.cnblogs.com/maybe2030/p/4781555.html#_label7)


