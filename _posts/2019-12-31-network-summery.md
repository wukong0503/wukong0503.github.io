---
title: 【整理】计算机网络
tags: 计算机网络
key: 2019123101
---



## OSI七层模型和TCP/IP四层模型

### 应用层
**应用层的任务是通过进程间的交互来完成特定的网络应用。
应用层协议定义的是应用进程间的通信和交互的规则。**
对于不同的应用需要不同的应用层协议。如域名系统DNS，支持万维网应用的HTTP协议，支持电子邮件的SMTP协议等等。
我们把应用层交互的数据单元称为报文。

### 传输层
**运输层的主要任务是负责向两台主机进程间的通信提供通用的数据传输服务。**
**传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题；**

运输层主要使用以下两种协议:
 - 传输控制协议 TCP（Transmission Control Protocol）：提供面向连接的，可靠的数据传输服务。
 - 用户数据协议 UDP（User Datagram Protocol）：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。

网络层只是根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到相应的端口。

### 网络层
**网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能；**基本数据单位为IP数据报；  
包含的主要协议：
 - IP协议（Internet Protocol，因特网互联协议）;
 - ICMP协议（Internet Control Message Protocol，因特网控制报文协议）;
 - ARP协议（Address Resolution Protocol，地址解析协议）;
 - RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。

### 数据链路层
**数据链路层为网络层提供可靠的数据传输；主要功能有：**  
 - 将数据组合成数据块，在数据链路层中称这种数据块为帧（frame），帧是数据链路层的传送单位；
 - 控制帧在物理信道上的传输，包括如何处理传输差错，调节发送速率以使与接收方相匹配（流量控制、数据的检错、重发）；
 - 以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。

### 物理层
物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。  
该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输。

#### 三次握手与四次挥手过程

##### 三次握手

三次握手的目的是连接服务器指定端口，建立TCP连接，同步连接双方的序列号和确认号，并交换TCP窗口大小信息。
在socket编程中，客户端执行connect()时, 将触发三次握手。  

 - 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 `SYN_SEND` 状态。  

首部的同步位`SYN=1`，初始序号`seq=x`，**`SYN=1`的报文段不能携带数据**，但要消耗掉一个序号。


 - 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。  

在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。


 - 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。  

确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），**ACK报文段可以携带数据，不携带数据则不消耗序号**。


##### 为什么需要三次握手，两次不行吗？
三次握手的目的是建立可靠的通信信道，说道通讯，简单来说就是数据的发送和接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。

 + 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
 + 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。
 + 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

因此，需要三次握手才能确认双方的接收与发送能力是否正常。  
试想如果是用两次握手，则会出现下面这种情况：  

 > 如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。


##### 四次挥手
 - 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。  
 - 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。此时TCP链接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。    
 - 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。 
 - 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。


##### 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？
这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送。


[https://zhuanlan.zhihu.com/p/53374516](https://zhuanlan.zhihu.com/p/53374516)  
[https://juejin.im/post/5d9c284b518825095879e7a5](https://juejin.im/post/5d9c284b518825095879e7a5)


##### 客户端不断进行请求链接会怎样？DDos(Distributed Denial of Service)攻击？
服务器端会为每个请求创建一个链接，并向其发送确认报文，然后等待客户端进行确认。  

1)、DDos 攻击  
客户端向服务端发送请求链接数据包  
服务端向客户端发送确认数据包  
客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认  

2)、DDos 预防 ( 没有彻底根治的办法，除非不使用TCP )  
限制同时打开SYN半链接的数目  
缩短SYN半链接的Time out 时间  
关闭不必要的服务  


#### TCP与UDP

##### TCP与UDP的区别
##### TCP报文格式

![TCP报文格式](https://s1.51cto.com/images/20180821/1534845641472393.jpeg)

TCP报文由首部和数据两部分组成。首部一般由20-60字节（Byte）构成，长度可变。其中前20B格式固定，后40B为可选。

上图中有几个字段需要重点介绍下：   
 + **源端口与目标端口**: 分别写入源端口号和目标端口号
 + **序列号**: 也就是我们tcp三次握手中的`seq`, 表示的是我们tcp数据段发送的第一个字节的序号,范围[0, 2^32 - 1], 例如,我们的seq = 201,携带的数据有100,那么最后一个字节的序号就为300, 那么下一个报文段就应该从301开始.  
 + **确认序列号**: 也就是`ack`(假设为y), 它的值是`seq+1`,表示的意义是y之前的数据我都收到了,下一个我期望收到的数据是y.也就是我回过去的seq = y.  
 + **标志位**：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：  
   + （A）URG：紧急指针（urgent pointer）有效。  
   + （B）ACK：确认序号有效。  
   + （C）PSH：接收方应该尽快将这个报文交给应用层。  
   + （D）RST：重置连接。  
   + （E）SYN：发起一个新连接。  
   + （F）FIN：释放一个连接。  

需要注意的是：  
    （A）不要将确认序号Ack与标志位中的ACK搞混了。  
    （B）确认方Ack=发起方Seq+1，两端配对。


##### TCP协议如何来保证传输的可靠性

##### 滑动窗口和流量控制

##### 拥塞控制


#### HTTP和HTTPS

##### HTTP和HTTPS的区别

1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。  
2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。  
3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。  
4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 

[http://www.mahaixiang.cn/internet/1233.html](http://www.mahaixiang.cn/internet/1233.html)

##### HTTP长连接、短连接，优点和缺点，使用场景

##### HTTP1.0和HTTP1.1的主要区别是什么?

##### HTTP2.0

##### Cookie和Session

#### GET与POST的区别

#### 对称加密与非对称加密
对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；  
而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。

由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；**但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。**


#### 从输入网址到获得页面的过程☆☆☆☆☆

#### Socket是什么

Socket是应用层与TCP/IP协议簇通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实是一个门面模式，它把复杂的TCP/IP协议隐藏在Socket接口后面，
对用户来说，一组简单的接口就是全部，让Socket去组织数据，已符合指定的协议。

#### 参考
[JavaGuide/network](https://github.com/Snailclimb/JavaGuide/blob/master/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md)
[计算机网络基础知识总结](https://www.cnblogs.com/maybe2030/p/4781555.html#_label7)

https://www.cnblogs.com/maybe2030/p/4781555.html
